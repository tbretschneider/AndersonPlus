var documenterSearchIndex = {"docs":
[{"location":"#AndersonPlus.jl","page":"Home","title":"AndersonPlus.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The best summation package.","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Sum the squares of two numbers","category":"page"},{"location":"#Function-Documentation","page":"Home","title":"Function Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"AASolve","category":"page"},{"location":"#AndersonPlus.AASolve","page":"Home","title":"AndersonPlus.AASolve","text":"AASolve(input::AAInput) :: AAOutput\n\nSolves a fixed-point iteration problem using Anderson acceleration or another iterative method as specified in the input.\n\nArguments\n\ninput::AAInput: The input object containing the following components:\nproblem: Specifies the fixed-point problem to solve, including:\nx0: The initial guess for the solution.\nGFix!: The function that computes the fixed-point iteration step.\nconvparams: Convergence parameters to determine when the solution is reached.\nalgorithm: Defines the iterative algorithm to use, including:\nmethod: The method for computing the next iterate (e.g., Anderson acceleration).\nalgorithmparams: Parameters specific to the chosen algorithm, such as maxit (maximum iterations).\nanalyses: Specifies the analysis and output settings, including:\nliveanalysis: A function or data used for live analysis during iterations.\nmidanalysis: A function or data used for intermediate analysis at each iteration.\nupdatefreq: Frequency (in iterations) to update live analysis output.\nsummary: Summary settings for post-analysis outputs.\n\nReturns\n\nAAOutput: An object containing the following components:\nsolution: The computed solution after the iterations converge.\ninput: The original input passed to the function.\npostanalysis: The results of the post-analysis, including convergence information and intermediate data.\n\nMethod\n\nInitializes the variables:\nx_0: Initial solution guess.\nGFix!: Fixed-point update function.\nHS: Historical data object (e.g., for storing intermediate states).\nCreates helper functions for:\nCalculating the next iterate (calcx_kp1!).\nPerforming live analysis (liveanalysisfunc).\nPerforming mid-iteration analysis (midanalysisfunc).\nIterates until convergence or maximum iterations are reached:\nComputes the next iterate.\nUpdates historical data and performs analyses.\nChecks for convergence based on specified tolerances.\nAfter convergence or termination:\nPerforms post-analysis.\nOutputs results based on summary settings.\nReturns the solution, along with relevant analysis outputs.\n\nNotes\n\nThe method used for iteration is determined by the method field in input.algorithm.\nConvergence is checked using a combination of tolerances specified in input.problem.convparams.\nPost-analysis results are generated after the iterative process completes.\n\nExample\n\n# Define the problem\nproblem = AAProblem(x0, GFix!, convparams)\n\n# Define the algorithm and its parameters\nalgorithm = AAAlgorithm(method, algorithmparams)\n\n# Define analysis and output settings\nanalyses = AAAnalyses(liveanalysis, midanalysis, updatefreq, summary)\n\n# Create the AAInput object\ninput = AAInput(problem, algorithm, analyses)\n\n# Solve the problem\noutput = AASolve(input)\n\n# Access the solution and analysis results\nsolution = output.solution\npostanalysis = output.postanalysis\n\nSee Also\n\ncreate_next_iterate_function\ninitialise_historicalstuff\nchecktolerances\noutput_liveanalysis\noutput_postanalysis\n\n\n\n\n\n","category":"function"}]
}
